// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.1
// source: hypurr.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Telegram_TelegramUser_FullMethodName           = "/hypurr.Telegram/TelegramUser"
	Telegram_TelegramUserWallets_FullMethodName    = "/hypurr.Telegram/TelegramUserWallets"
	Telegram_HyperliquidLaunchTrade_FullMethodName = "/hypurr.Telegram/HyperliquidLaunchTrade"
)

// TelegramClient is the client API for Telegram service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TelegramClient interface {
	TelegramUser(ctx context.Context, in *TelegramUserRequest, opts ...grpc.CallOption) (*TelegramUserResponse, error)
	TelegramUserWallets(ctx context.Context, in *TelegramUserWalletsRequest, opts ...grpc.CallOption) (*TelegramUserWalletsResponse, error)
	HyperliquidLaunchTrade(ctx context.Context, in *HyperliquidLaunchTradeRequest, opts ...grpc.CallOption) (*HyperliquidLaunchTradeResponse, error)
}

type telegramClient struct {
	cc grpc.ClientConnInterface
}

func NewTelegramClient(cc grpc.ClientConnInterface) TelegramClient {
	return &telegramClient{cc}
}

func (c *telegramClient) TelegramUser(ctx context.Context, in *TelegramUserRequest, opts ...grpc.CallOption) (*TelegramUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TelegramUserResponse)
	err := c.cc.Invoke(ctx, Telegram_TelegramUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telegramClient) TelegramUserWallets(ctx context.Context, in *TelegramUserWalletsRequest, opts ...grpc.CallOption) (*TelegramUserWalletsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TelegramUserWalletsResponse)
	err := c.cc.Invoke(ctx, Telegram_TelegramUserWallets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telegramClient) HyperliquidLaunchTrade(ctx context.Context, in *HyperliquidLaunchTradeRequest, opts ...grpc.CallOption) (*HyperliquidLaunchTradeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidLaunchTradeResponse)
	err := c.cc.Invoke(ctx, Telegram_HyperliquidLaunchTrade_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TelegramServer is the server API for Telegram service.
// All implementations must embed UnimplementedTelegramServer
// for forward compatibility.
type TelegramServer interface {
	TelegramUser(context.Context, *TelegramUserRequest) (*TelegramUserResponse, error)
	TelegramUserWallets(context.Context, *TelegramUserWalletsRequest) (*TelegramUserWalletsResponse, error)
	HyperliquidLaunchTrade(context.Context, *HyperliquidLaunchTradeRequest) (*HyperliquidLaunchTradeResponse, error)
	mustEmbedUnimplementedTelegramServer()
}

// UnimplementedTelegramServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTelegramServer struct{}

func (UnimplementedTelegramServer) TelegramUser(context.Context, *TelegramUserRequest) (*TelegramUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TelegramUser not implemented")
}
func (UnimplementedTelegramServer) TelegramUserWallets(context.Context, *TelegramUserWalletsRequest) (*TelegramUserWalletsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TelegramUserWallets not implemented")
}
func (UnimplementedTelegramServer) HyperliquidLaunchTrade(context.Context, *HyperliquidLaunchTradeRequest) (*HyperliquidLaunchTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidLaunchTrade not implemented")
}
func (UnimplementedTelegramServer) mustEmbedUnimplementedTelegramServer() {}
func (UnimplementedTelegramServer) testEmbeddedByValue()                  {}

// UnsafeTelegramServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TelegramServer will
// result in compilation errors.
type UnsafeTelegramServer interface {
	mustEmbedUnimplementedTelegramServer()
}

func RegisterTelegramServer(s grpc.ServiceRegistrar, srv TelegramServer) {
	// If the following call pancis, it indicates UnimplementedTelegramServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Telegram_ServiceDesc, srv)
}

func _Telegram_TelegramUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TelegramUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelegramServer).TelegramUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Telegram_TelegramUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelegramServer).TelegramUser(ctx, req.(*TelegramUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telegram_TelegramUserWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TelegramUserWalletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelegramServer).TelegramUserWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Telegram_TelegramUserWallets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelegramServer).TelegramUserWallets(ctx, req.(*TelegramUserWalletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telegram_HyperliquidLaunchTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidLaunchTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelegramServer).HyperliquidLaunchTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Telegram_HyperliquidLaunchTrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelegramServer).HyperliquidLaunchTrade(ctx, req.(*HyperliquidLaunchTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Telegram_ServiceDesc is the grpc.ServiceDesc for Telegram service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Telegram_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hypurr.Telegram",
	HandlerType: (*TelegramServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TelegramUser",
			Handler:    _Telegram_TelegramUser_Handler,
		},
		{
			MethodName: "TelegramUserWallets",
			Handler:    _Telegram_TelegramUserWallets_Handler,
		},
		{
			MethodName: "HyperliquidLaunchTrade",
			Handler:    _Telegram_HyperliquidLaunchTrade_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hypurr.proto",
}

const (
	Static_HyperliquidDeployAuction_FullMethodName                   = "/hypurr.Static/HyperliquidDeployAuction"
	Static_HyperliquidTokens_FullMethodName                          = "/hypurr.Static/HyperliquidTokens"
	Static_HyperliquidTokenHolders_FullMethodName                    = "/hypurr.Static/HyperliquidTokenHolders"
	Static_HyperliquidTokenMessages_FullMethodName                   = "/hypurr.Static/HyperliquidTokenMessages"
	Static_HyperliquidSpotPair_FullMethodName                        = "/hypurr.Static/HyperliquidSpotPair"
	Static_HyperliquidSpotPairs_FullMethodName                       = "/hypurr.Static/HyperliquidSpotPairs"
	Static_HyperliquidPerpPairs_FullMethodName                       = "/hypurr.Static/HyperliquidPerpPairs"
	Static_HyperliquidWallet_FullMethodName                          = "/hypurr.Static/HyperliquidWallet"
	Static_HyperliquidWalletDeploySessions_FullMethodName            = "/hypurr.Static/HyperliquidWalletDeploySessions"
	Static_HyperliquidWalletPerformance_FullMethodName               = "/hypurr.Static/HyperliquidWalletPerformance"
	Static_HyperliquidLaunch_FullMethodName                          = "/hypurr.Static/HyperliquidLaunch"
	Static_HyperliquidLaunches_FullMethodName                        = "/hypurr.Static/HyperliquidLaunches"
	Static_HyperliquidLaunchStream_FullMethodName                    = "/hypurr.Static/HyperliquidLaunchStream"
	Static_HyperliquidLaunchFills_FullMethodName                     = "/hypurr.Static/HyperliquidLaunchFills"
	Static_HyperliquidLaunchCandles_FullMethodName                   = "/hypurr.Static/HyperliquidLaunchCandles"
	Static_HyperliquidLaunchCandleStream_FullMethodName              = "/hypurr.Static/HyperliquidLaunchCandleStream"
	Static_HyperliquidLaunchMessages_FullMethodName                  = "/hypurr.Static/HyperliquidLaunchMessages"
	Static_LatestHyperliquidLaunchFills_FullMethodName               = "/hypurr.Static/LatestHyperliquidLaunchFills"
	Static_HyperliquidLaunchHolders_FullMethodName                   = "/hypurr.Static/HyperliquidLaunchHolders"
	Static_HypurrFunCabals_FullMethodName                            = "/hypurr.Static/HypurrFunCabals"
	Static_SetHyperliquidWalletDeploySessionTarget_FullMethodName    = "/hypurr.Static/SetHyperliquidWalletDeploySessionTarget"
	Static_DeleteHyperliquidWalletDeploySessionTarget_FullMethodName = "/hypurr.Static/DeleteHyperliquidWalletDeploySessionTarget"
)

// StaticClient is the client API for Static service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StaticClient interface {
	HyperliquidDeployAuction(ctx context.Context, in *HyperliquidDeployAuctionRequest, opts ...grpc.CallOption) (*HyperliquidDeployAuctionResponse, error)
	HyperliquidTokens(ctx context.Context, in *HyperliquidTokensRequest, opts ...grpc.CallOption) (*HyperliquidTokensResponse, error)
	HyperliquidTokenHolders(ctx context.Context, in *HyperliquidTokenHoldersRequest, opts ...grpc.CallOption) (*HyperliquidTokenHoldersResponse, error)
	HyperliquidTokenMessages(ctx context.Context, in *HyperliquidTokenMessagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidTokenMessagesResponse], error)
	HyperliquidSpotPair(ctx context.Context, in *HyperliquidSpotPairRequest, opts ...grpc.CallOption) (*HyperliquidSpotPairResponse, error)
	HyperliquidSpotPairs(ctx context.Context, in *HyperliquidSpotPairsRequest, opts ...grpc.CallOption) (*HyperliquidSpotPairsResponse, error)
	HyperliquidPerpPairs(ctx context.Context, in *HyperliquidPerpPairsRequest, opts ...grpc.CallOption) (*HyperliquidPerpPairsResponse, error)
	HyperliquidWallet(ctx context.Context, in *HyperliquidWalletRequest, opts ...grpc.CallOption) (*HyperliquidWalletResponse, error)
	HyperliquidWalletDeploySessions(ctx context.Context, in *HyperliquidWalletDeploySessionsRequest, opts ...grpc.CallOption) (*HyperliquidWalletDeploySessionsResponse, error)
	HyperliquidWalletPerformance(ctx context.Context, in *HyperliquidWalletPerformanceRequest, opts ...grpc.CallOption) (*HyperliquidWalletPerformanceResponse, error)
	HyperliquidLaunch(ctx context.Context, in *HyperliquidLaunchRequest, opts ...grpc.CallOption) (*HyperliquidLaunchResponse, error)
	HyperliquidLaunches(ctx context.Context, in *HyperliquidLaunchesRequest, opts ...grpc.CallOption) (*HyperliquidLaunchesResponse, error)
	HyperliquidLaunchStream(ctx context.Context, in *HyperliquidLaunchStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidLaunchStreamResponse], error)
	HyperliquidLaunchFills(ctx context.Context, in *HyperliquidLaunchFillsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidLaunchFillsResponse], error)
	HyperliquidLaunchCandles(ctx context.Context, in *HyperliquidLaunchCandlesRequest, opts ...grpc.CallOption) (*HyperliquidLaunchCandlesResponse, error)
	HyperliquidLaunchCandleStream(ctx context.Context, in *HyperliquidLaunchCandlesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidLaunchCandlesResponse], error)
	HyperliquidLaunchMessages(ctx context.Context, in *HyperliquidLaunchMessagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidLaunchMessagesResponse], error)
	LatestHyperliquidLaunchFills(ctx context.Context, in *LatestHyperliquidLaunchFillsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidLaunchFillsResponse], error)
	HyperliquidLaunchHolders(ctx context.Context, in *HyperliquidLaunchHoldersRequest, opts ...grpc.CallOption) (*HyperliquidLaunchHoldersResponse, error)
	HypurrFunCabals(ctx context.Context, in *HypurrFunCabalsRequest, opts ...grpc.CallOption) (*HypurrFunCabalsResponse, error)
	SetHyperliquidWalletDeploySessionTarget(ctx context.Context, in *SetHyperliquidWalletDeploySessionTargetRequest, opts ...grpc.CallOption) (*SetHyperliquidWalletDeploySessionTargetResponse, error)
	DeleteHyperliquidWalletDeploySessionTarget(ctx context.Context, in *DeleteHyperliquidWalletDeploySessionTargetRequest, opts ...grpc.CallOption) (*DeleteHyperliquidWalletDeploySessionTargetResponse, error)
}

type staticClient struct {
	cc grpc.ClientConnInterface
}

func NewStaticClient(cc grpc.ClientConnInterface) StaticClient {
	return &staticClient{cc}
}

func (c *staticClient) HyperliquidDeployAuction(ctx context.Context, in *HyperliquidDeployAuctionRequest, opts ...grpc.CallOption) (*HyperliquidDeployAuctionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidDeployAuctionResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidDeployAuction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidTokens(ctx context.Context, in *HyperliquidTokensRequest, opts ...grpc.CallOption) (*HyperliquidTokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidTokensResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidTokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidTokenHolders(ctx context.Context, in *HyperliquidTokenHoldersRequest, opts ...grpc.CallOption) (*HyperliquidTokenHoldersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidTokenHoldersResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidTokenHolders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidTokenMessages(ctx context.Context, in *HyperliquidTokenMessagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidTokenMessagesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Static_ServiceDesc.Streams[0], Static_HyperliquidTokenMessages_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HyperliquidTokenMessagesRequest, HyperliquidTokenMessagesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_HyperliquidTokenMessagesClient = grpc.ServerStreamingClient[HyperliquidTokenMessagesResponse]

func (c *staticClient) HyperliquidSpotPair(ctx context.Context, in *HyperliquidSpotPairRequest, opts ...grpc.CallOption) (*HyperliquidSpotPairResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidSpotPairResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidSpotPair_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidSpotPairs(ctx context.Context, in *HyperliquidSpotPairsRequest, opts ...grpc.CallOption) (*HyperliquidSpotPairsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidSpotPairsResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidSpotPairs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidPerpPairs(ctx context.Context, in *HyperliquidPerpPairsRequest, opts ...grpc.CallOption) (*HyperliquidPerpPairsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidPerpPairsResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidPerpPairs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidWallet(ctx context.Context, in *HyperliquidWalletRequest, opts ...grpc.CallOption) (*HyperliquidWalletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidWalletResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidWallet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidWalletDeploySessions(ctx context.Context, in *HyperliquidWalletDeploySessionsRequest, opts ...grpc.CallOption) (*HyperliquidWalletDeploySessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidWalletDeploySessionsResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidWalletDeploySessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidWalletPerformance(ctx context.Context, in *HyperliquidWalletPerformanceRequest, opts ...grpc.CallOption) (*HyperliquidWalletPerformanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidWalletPerformanceResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidWalletPerformance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidLaunch(ctx context.Context, in *HyperliquidLaunchRequest, opts ...grpc.CallOption) (*HyperliquidLaunchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidLaunchResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidLaunch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidLaunches(ctx context.Context, in *HyperliquidLaunchesRequest, opts ...grpc.CallOption) (*HyperliquidLaunchesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidLaunchesResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidLaunches_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidLaunchStream(ctx context.Context, in *HyperliquidLaunchStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidLaunchStreamResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Static_ServiceDesc.Streams[1], Static_HyperliquidLaunchStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HyperliquidLaunchStreamRequest, HyperliquidLaunchStreamResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_HyperliquidLaunchStreamClient = grpc.ServerStreamingClient[HyperliquidLaunchStreamResponse]

func (c *staticClient) HyperliquidLaunchFills(ctx context.Context, in *HyperliquidLaunchFillsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidLaunchFillsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Static_ServiceDesc.Streams[2], Static_HyperliquidLaunchFills_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HyperliquidLaunchFillsRequest, HyperliquidLaunchFillsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_HyperliquidLaunchFillsClient = grpc.ServerStreamingClient[HyperliquidLaunchFillsResponse]

func (c *staticClient) HyperliquidLaunchCandles(ctx context.Context, in *HyperliquidLaunchCandlesRequest, opts ...grpc.CallOption) (*HyperliquidLaunchCandlesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidLaunchCandlesResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidLaunchCandles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HyperliquidLaunchCandleStream(ctx context.Context, in *HyperliquidLaunchCandlesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidLaunchCandlesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Static_ServiceDesc.Streams[3], Static_HyperliquidLaunchCandleStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HyperliquidLaunchCandlesRequest, HyperliquidLaunchCandlesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_HyperliquidLaunchCandleStreamClient = grpc.ServerStreamingClient[HyperliquidLaunchCandlesResponse]

func (c *staticClient) HyperliquidLaunchMessages(ctx context.Context, in *HyperliquidLaunchMessagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidLaunchMessagesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Static_ServiceDesc.Streams[4], Static_HyperliquidLaunchMessages_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HyperliquidLaunchMessagesRequest, HyperliquidLaunchMessagesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_HyperliquidLaunchMessagesClient = grpc.ServerStreamingClient[HyperliquidLaunchMessagesResponse]

func (c *staticClient) LatestHyperliquidLaunchFills(ctx context.Context, in *LatestHyperliquidLaunchFillsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HyperliquidLaunchFillsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Static_ServiceDesc.Streams[5], Static_LatestHyperliquidLaunchFills_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LatestHyperliquidLaunchFillsRequest, HyperliquidLaunchFillsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_LatestHyperliquidLaunchFillsClient = grpc.ServerStreamingClient[HyperliquidLaunchFillsResponse]

func (c *staticClient) HyperliquidLaunchHolders(ctx context.Context, in *HyperliquidLaunchHoldersRequest, opts ...grpc.CallOption) (*HyperliquidLaunchHoldersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HyperliquidLaunchHoldersResponse)
	err := c.cc.Invoke(ctx, Static_HyperliquidLaunchHolders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) HypurrFunCabals(ctx context.Context, in *HypurrFunCabalsRequest, opts ...grpc.CallOption) (*HypurrFunCabalsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HypurrFunCabalsResponse)
	err := c.cc.Invoke(ctx, Static_HypurrFunCabals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) SetHyperliquidWalletDeploySessionTarget(ctx context.Context, in *SetHyperliquidWalletDeploySessionTargetRequest, opts ...grpc.CallOption) (*SetHyperliquidWalletDeploySessionTargetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetHyperliquidWalletDeploySessionTargetResponse)
	err := c.cc.Invoke(ctx, Static_SetHyperliquidWalletDeploySessionTarget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *staticClient) DeleteHyperliquidWalletDeploySessionTarget(ctx context.Context, in *DeleteHyperliquidWalletDeploySessionTargetRequest, opts ...grpc.CallOption) (*DeleteHyperliquidWalletDeploySessionTargetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteHyperliquidWalletDeploySessionTargetResponse)
	err := c.cc.Invoke(ctx, Static_DeleteHyperliquidWalletDeploySessionTarget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StaticServer is the server API for Static service.
// All implementations must embed UnimplementedStaticServer
// for forward compatibility.
type StaticServer interface {
	HyperliquidDeployAuction(context.Context, *HyperliquidDeployAuctionRequest) (*HyperliquidDeployAuctionResponse, error)
	HyperliquidTokens(context.Context, *HyperliquidTokensRequest) (*HyperliquidTokensResponse, error)
	HyperliquidTokenHolders(context.Context, *HyperliquidTokenHoldersRequest) (*HyperliquidTokenHoldersResponse, error)
	HyperliquidTokenMessages(*HyperliquidTokenMessagesRequest, grpc.ServerStreamingServer[HyperliquidTokenMessagesResponse]) error
	HyperliquidSpotPair(context.Context, *HyperliquidSpotPairRequest) (*HyperliquidSpotPairResponse, error)
	HyperliquidSpotPairs(context.Context, *HyperliquidSpotPairsRequest) (*HyperliquidSpotPairsResponse, error)
	HyperliquidPerpPairs(context.Context, *HyperliquidPerpPairsRequest) (*HyperliquidPerpPairsResponse, error)
	HyperliquidWallet(context.Context, *HyperliquidWalletRequest) (*HyperliquidWalletResponse, error)
	HyperliquidWalletDeploySessions(context.Context, *HyperliquidWalletDeploySessionsRequest) (*HyperliquidWalletDeploySessionsResponse, error)
	HyperliquidWalletPerformance(context.Context, *HyperliquidWalletPerformanceRequest) (*HyperliquidWalletPerformanceResponse, error)
	HyperliquidLaunch(context.Context, *HyperliquidLaunchRequest) (*HyperliquidLaunchResponse, error)
	HyperliquidLaunches(context.Context, *HyperliquidLaunchesRequest) (*HyperliquidLaunchesResponse, error)
	HyperliquidLaunchStream(*HyperliquidLaunchStreamRequest, grpc.ServerStreamingServer[HyperliquidLaunchStreamResponse]) error
	HyperliquidLaunchFills(*HyperliquidLaunchFillsRequest, grpc.ServerStreamingServer[HyperliquidLaunchFillsResponse]) error
	HyperliquidLaunchCandles(context.Context, *HyperliquidLaunchCandlesRequest) (*HyperliquidLaunchCandlesResponse, error)
	HyperliquidLaunchCandleStream(*HyperliquidLaunchCandlesRequest, grpc.ServerStreamingServer[HyperliquidLaunchCandlesResponse]) error
	HyperliquidLaunchMessages(*HyperliquidLaunchMessagesRequest, grpc.ServerStreamingServer[HyperliquidLaunchMessagesResponse]) error
	LatestHyperliquidLaunchFills(*LatestHyperliquidLaunchFillsRequest, grpc.ServerStreamingServer[HyperliquidLaunchFillsResponse]) error
	HyperliquidLaunchHolders(context.Context, *HyperliquidLaunchHoldersRequest) (*HyperliquidLaunchHoldersResponse, error)
	HypurrFunCabals(context.Context, *HypurrFunCabalsRequest) (*HypurrFunCabalsResponse, error)
	SetHyperliquidWalletDeploySessionTarget(context.Context, *SetHyperliquidWalletDeploySessionTargetRequest) (*SetHyperliquidWalletDeploySessionTargetResponse, error)
	DeleteHyperliquidWalletDeploySessionTarget(context.Context, *DeleteHyperliquidWalletDeploySessionTargetRequest) (*DeleteHyperliquidWalletDeploySessionTargetResponse, error)
	mustEmbedUnimplementedStaticServer()
}

// UnimplementedStaticServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStaticServer struct{}

func (UnimplementedStaticServer) HyperliquidDeployAuction(context.Context, *HyperliquidDeployAuctionRequest) (*HyperliquidDeployAuctionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidDeployAuction not implemented")
}
func (UnimplementedStaticServer) HyperliquidTokens(context.Context, *HyperliquidTokensRequest) (*HyperliquidTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidTokens not implemented")
}
func (UnimplementedStaticServer) HyperliquidTokenHolders(context.Context, *HyperliquidTokenHoldersRequest) (*HyperliquidTokenHoldersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidTokenHolders not implemented")
}
func (UnimplementedStaticServer) HyperliquidTokenMessages(*HyperliquidTokenMessagesRequest, grpc.ServerStreamingServer[HyperliquidTokenMessagesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method HyperliquidTokenMessages not implemented")
}
func (UnimplementedStaticServer) HyperliquidSpotPair(context.Context, *HyperliquidSpotPairRequest) (*HyperliquidSpotPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidSpotPair not implemented")
}
func (UnimplementedStaticServer) HyperliquidSpotPairs(context.Context, *HyperliquidSpotPairsRequest) (*HyperliquidSpotPairsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidSpotPairs not implemented")
}
func (UnimplementedStaticServer) HyperliquidPerpPairs(context.Context, *HyperliquidPerpPairsRequest) (*HyperliquidPerpPairsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidPerpPairs not implemented")
}
func (UnimplementedStaticServer) HyperliquidWallet(context.Context, *HyperliquidWalletRequest) (*HyperliquidWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidWallet not implemented")
}
func (UnimplementedStaticServer) HyperliquidWalletDeploySessions(context.Context, *HyperliquidWalletDeploySessionsRequest) (*HyperliquidWalletDeploySessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidWalletDeploySessions not implemented")
}
func (UnimplementedStaticServer) HyperliquidWalletPerformance(context.Context, *HyperliquidWalletPerformanceRequest) (*HyperliquidWalletPerformanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidWalletPerformance not implemented")
}
func (UnimplementedStaticServer) HyperliquidLaunch(context.Context, *HyperliquidLaunchRequest) (*HyperliquidLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidLaunch not implemented")
}
func (UnimplementedStaticServer) HyperliquidLaunches(context.Context, *HyperliquidLaunchesRequest) (*HyperliquidLaunchesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidLaunches not implemented")
}
func (UnimplementedStaticServer) HyperliquidLaunchStream(*HyperliquidLaunchStreamRequest, grpc.ServerStreamingServer[HyperliquidLaunchStreamResponse]) error {
	return status.Errorf(codes.Unimplemented, "method HyperliquidLaunchStream not implemented")
}
func (UnimplementedStaticServer) HyperliquidLaunchFills(*HyperliquidLaunchFillsRequest, grpc.ServerStreamingServer[HyperliquidLaunchFillsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method HyperliquidLaunchFills not implemented")
}
func (UnimplementedStaticServer) HyperliquidLaunchCandles(context.Context, *HyperliquidLaunchCandlesRequest) (*HyperliquidLaunchCandlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidLaunchCandles not implemented")
}
func (UnimplementedStaticServer) HyperliquidLaunchCandleStream(*HyperliquidLaunchCandlesRequest, grpc.ServerStreamingServer[HyperliquidLaunchCandlesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method HyperliquidLaunchCandleStream not implemented")
}
func (UnimplementedStaticServer) HyperliquidLaunchMessages(*HyperliquidLaunchMessagesRequest, grpc.ServerStreamingServer[HyperliquidLaunchMessagesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method HyperliquidLaunchMessages not implemented")
}
func (UnimplementedStaticServer) LatestHyperliquidLaunchFills(*LatestHyperliquidLaunchFillsRequest, grpc.ServerStreamingServer[HyperliquidLaunchFillsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method LatestHyperliquidLaunchFills not implemented")
}
func (UnimplementedStaticServer) HyperliquidLaunchHolders(context.Context, *HyperliquidLaunchHoldersRequest) (*HyperliquidLaunchHoldersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HyperliquidLaunchHolders not implemented")
}
func (UnimplementedStaticServer) HypurrFunCabals(context.Context, *HypurrFunCabalsRequest) (*HypurrFunCabalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HypurrFunCabals not implemented")
}
func (UnimplementedStaticServer) SetHyperliquidWalletDeploySessionTarget(context.Context, *SetHyperliquidWalletDeploySessionTargetRequest) (*SetHyperliquidWalletDeploySessionTargetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetHyperliquidWalletDeploySessionTarget not implemented")
}
func (UnimplementedStaticServer) DeleteHyperliquidWalletDeploySessionTarget(context.Context, *DeleteHyperliquidWalletDeploySessionTargetRequest) (*DeleteHyperliquidWalletDeploySessionTargetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHyperliquidWalletDeploySessionTarget not implemented")
}
func (UnimplementedStaticServer) mustEmbedUnimplementedStaticServer() {}
func (UnimplementedStaticServer) testEmbeddedByValue()                {}

// UnsafeStaticServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StaticServer will
// result in compilation errors.
type UnsafeStaticServer interface {
	mustEmbedUnimplementedStaticServer()
}

func RegisterStaticServer(s grpc.ServiceRegistrar, srv StaticServer) {
	// If the following call pancis, it indicates UnimplementedStaticServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Static_ServiceDesc, srv)
}

func _Static_HyperliquidDeployAuction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidDeployAuctionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidDeployAuction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidDeployAuction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidDeployAuction(ctx, req.(*HyperliquidDeployAuctionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidTokens(ctx, req.(*HyperliquidTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidTokenHolders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidTokenHoldersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidTokenHolders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidTokenHolders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidTokenHolders(ctx, req.(*HyperliquidTokenHoldersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidTokenMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HyperliquidTokenMessagesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StaticServer).HyperliquidTokenMessages(m, &grpc.GenericServerStream[HyperliquidTokenMessagesRequest, HyperliquidTokenMessagesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_HyperliquidTokenMessagesServer = grpc.ServerStreamingServer[HyperliquidTokenMessagesResponse]

func _Static_HyperliquidSpotPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidSpotPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidSpotPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidSpotPair_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidSpotPair(ctx, req.(*HyperliquidSpotPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidSpotPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidSpotPairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidSpotPairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidSpotPairs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidSpotPairs(ctx, req.(*HyperliquidSpotPairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidPerpPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidPerpPairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidPerpPairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidPerpPairs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidPerpPairs(ctx, req.(*HyperliquidPerpPairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidWallet(ctx, req.(*HyperliquidWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidWalletDeploySessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidWalletDeploySessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidWalletDeploySessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidWalletDeploySessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidWalletDeploySessions(ctx, req.(*HyperliquidWalletDeploySessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidWalletPerformance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidWalletPerformanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidWalletPerformance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidWalletPerformance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidWalletPerformance(ctx, req.(*HyperliquidWalletPerformanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidLaunchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidLaunch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidLaunch(ctx, req.(*HyperliquidLaunchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidLaunches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidLaunchesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidLaunches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidLaunches_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidLaunches(ctx, req.(*HyperliquidLaunchesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidLaunchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HyperliquidLaunchStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StaticServer).HyperliquidLaunchStream(m, &grpc.GenericServerStream[HyperliquidLaunchStreamRequest, HyperliquidLaunchStreamResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_HyperliquidLaunchStreamServer = grpc.ServerStreamingServer[HyperliquidLaunchStreamResponse]

func _Static_HyperliquidLaunchFills_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HyperliquidLaunchFillsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StaticServer).HyperliquidLaunchFills(m, &grpc.GenericServerStream[HyperliquidLaunchFillsRequest, HyperliquidLaunchFillsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_HyperliquidLaunchFillsServer = grpc.ServerStreamingServer[HyperliquidLaunchFillsResponse]

func _Static_HyperliquidLaunchCandles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidLaunchCandlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidLaunchCandles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidLaunchCandles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidLaunchCandles(ctx, req.(*HyperliquidLaunchCandlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HyperliquidLaunchCandleStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HyperliquidLaunchCandlesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StaticServer).HyperliquidLaunchCandleStream(m, &grpc.GenericServerStream[HyperliquidLaunchCandlesRequest, HyperliquidLaunchCandlesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_HyperliquidLaunchCandleStreamServer = grpc.ServerStreamingServer[HyperliquidLaunchCandlesResponse]

func _Static_HyperliquidLaunchMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HyperliquidLaunchMessagesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StaticServer).HyperliquidLaunchMessages(m, &grpc.GenericServerStream[HyperliquidLaunchMessagesRequest, HyperliquidLaunchMessagesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_HyperliquidLaunchMessagesServer = grpc.ServerStreamingServer[HyperliquidLaunchMessagesResponse]

func _Static_LatestHyperliquidLaunchFills_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LatestHyperliquidLaunchFillsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StaticServer).LatestHyperliquidLaunchFills(m, &grpc.GenericServerStream[LatestHyperliquidLaunchFillsRequest, HyperliquidLaunchFillsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Static_LatestHyperliquidLaunchFillsServer = grpc.ServerStreamingServer[HyperliquidLaunchFillsResponse]

func _Static_HyperliquidLaunchHolders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HyperliquidLaunchHoldersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HyperliquidLaunchHolders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HyperliquidLaunchHolders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HyperliquidLaunchHolders(ctx, req.(*HyperliquidLaunchHoldersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_HypurrFunCabals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HypurrFunCabalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).HypurrFunCabals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_HypurrFunCabals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).HypurrFunCabals(ctx, req.(*HypurrFunCabalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_SetHyperliquidWalletDeploySessionTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetHyperliquidWalletDeploySessionTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).SetHyperliquidWalletDeploySessionTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_SetHyperliquidWalletDeploySessionTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).SetHyperliquidWalletDeploySessionTarget(ctx, req.(*SetHyperliquidWalletDeploySessionTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Static_DeleteHyperliquidWalletDeploySessionTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHyperliquidWalletDeploySessionTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticServer).DeleteHyperliquidWalletDeploySessionTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Static_DeleteHyperliquidWalletDeploySessionTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticServer).DeleteHyperliquidWalletDeploySessionTarget(ctx, req.(*DeleteHyperliquidWalletDeploySessionTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Static_ServiceDesc is the grpc.ServiceDesc for Static service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Static_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hypurr.Static",
	HandlerType: (*StaticServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HyperliquidDeployAuction",
			Handler:    _Static_HyperliquidDeployAuction_Handler,
		},
		{
			MethodName: "HyperliquidTokens",
			Handler:    _Static_HyperliquidTokens_Handler,
		},
		{
			MethodName: "HyperliquidTokenHolders",
			Handler:    _Static_HyperliquidTokenHolders_Handler,
		},
		{
			MethodName: "HyperliquidSpotPair",
			Handler:    _Static_HyperliquidSpotPair_Handler,
		},
		{
			MethodName: "HyperliquidSpotPairs",
			Handler:    _Static_HyperliquidSpotPairs_Handler,
		},
		{
			MethodName: "HyperliquidPerpPairs",
			Handler:    _Static_HyperliquidPerpPairs_Handler,
		},
		{
			MethodName: "HyperliquidWallet",
			Handler:    _Static_HyperliquidWallet_Handler,
		},
		{
			MethodName: "HyperliquidWalletDeploySessions",
			Handler:    _Static_HyperliquidWalletDeploySessions_Handler,
		},
		{
			MethodName: "HyperliquidWalletPerformance",
			Handler:    _Static_HyperliquidWalletPerformance_Handler,
		},
		{
			MethodName: "HyperliquidLaunch",
			Handler:    _Static_HyperliquidLaunch_Handler,
		},
		{
			MethodName: "HyperliquidLaunches",
			Handler:    _Static_HyperliquidLaunches_Handler,
		},
		{
			MethodName: "HyperliquidLaunchCandles",
			Handler:    _Static_HyperliquidLaunchCandles_Handler,
		},
		{
			MethodName: "HyperliquidLaunchHolders",
			Handler:    _Static_HyperliquidLaunchHolders_Handler,
		},
		{
			MethodName: "HypurrFunCabals",
			Handler:    _Static_HypurrFunCabals_Handler,
		},
		{
			MethodName: "SetHyperliquidWalletDeploySessionTarget",
			Handler:    _Static_SetHyperliquidWalletDeploySessionTarget_Handler,
		},
		{
			MethodName: "DeleteHyperliquidWalletDeploySessionTarget",
			Handler:    _Static_DeleteHyperliquidWalletDeploySessionTarget_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "HyperliquidTokenMessages",
			Handler:       _Static_HyperliquidTokenMessages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HyperliquidLaunchStream",
			Handler:       _Static_HyperliquidLaunchStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HyperliquidLaunchFills",
			Handler:       _Static_HyperliquidLaunchFills_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HyperliquidLaunchCandleStream",
			Handler:       _Static_HyperliquidLaunchCandleStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HyperliquidLaunchMessages",
			Handler:       _Static_HyperliquidLaunchMessages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LatestHyperliquidLaunchFills",
			Handler:       _Static_LatestHyperliquidLaunchFills_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "hypurr.proto",
}
